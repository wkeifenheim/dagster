schema {
  query: DagitQuery
  mutation: DagitMutation
  subscription: DagitSubscription
}

type DagitQuery {
  version: String!
  repositoriesOrError: RepositoriesOrError!
  repositoryOrError(repositorySelector: RepositorySelector!): RepositoryOrError!
  workspaceOrError: WorkspaceOrError!
  pipelineOrError(params: PipelineSelector!): PipelineOrError!
  pipelineSnapshotOrError(snapshotId: String, activePipelineSelector: PipelineSelector): PipelineSnapshotOrError!
  graphOrError(selector: GraphSelector): GraphOrError!
  scheduler: SchedulerOrError!
  scheduleOrError(scheduleSelector: ScheduleSelector!): ScheduleOrError!
  schedulesOrError(repositorySelector: RepositorySelector!): SchedulesOrError!
  sensorOrError(sensorSelector: SensorSelector!): SensorOrError!
  sensorsOrError(repositorySelector: RepositorySelector!): SensorsOrError!
  instigationStateOrError(instigationSelector: InstigationSelector!): InstigationStateOrError!
  unloadableInstigationStatesOrError(instigationType: InstigationType): InstigationStatesOrError!
  partitionSetsOrError(repositorySelector: RepositorySelector!, pipelineName: String!): PartitionSetsOrError!
  partitionSetOrError(repositorySelector: RepositorySelector!, partitionSetName: String): PartitionSetOrError!
  pipelineRunsOrError(filter: RunsFilter, cursor: String, limit: Int): RunsOrError!
  pipelineRunOrError(runId: ID!): RunOrError!
  runsOrError(filter: RunsFilter, cursor: String, limit: Int): RunsOrError!
  runOrError(runId: ID!): RunOrError!
  pipelineRunTags: [PipelineTagAndValues!]!
  runGroupOrError(runId: ID!): RunGroupOrError!
  runGroupsOrError(filter: RunsFilter, cursor: String, limit: Int): RunGroupsOrError!
  isPipelineConfigValid(pipeline: PipelineSelector!, runConfigData: RunConfigData, mode: String!): PipelineConfigValidationResult!
  executionPlanOrError(pipeline: PipelineSelector!, runConfigData: RunConfigData, mode: String!): ExecutionPlanOrError!
  runConfigSchemaOrError(selector: PipelineSelector!, mode: String): RunConfigSchemaOrError!
  instance: Instance!
  assetsOrError(prefix: [String!], cursor: String, limit: Int): AssetsOrError!
  assetOrError(assetKey: AssetKeyInput!): AssetOrError!
  assetNodes: [AssetNode!]!
  assetNodeOrError(assetKey: AssetKeyInput!): AssetNodeOrError!
  partitionBackfillOrError(backfillId: String!): PartitionBackfillOrError!
  partitionBackfillsOrError(cursor: String, limit: Int): PartitionBackfillsOrError!
  permissions: [GraphenePermission!]!
}

union RepositoriesOrError = RepositoryConnection | PythonError

type RepositoryConnection {
  nodes: [Repository!]!
}

type Repository {
  id: ID!
  name: String!
  location: RepositoryLocation!
  pipelines: [Pipeline!]!
  jobs: [Job!]!
  usedSolids: [UsedSolid!]!
  usedSolid(name: String!): UsedSolid
  origin: RepositoryOrigin!
  partitionSets: [PartitionSet!]!
  schedules: [Schedule!]!
  sensors: [Sensor!]!
  assetNodes: [AssetNode!]!
  displayMetadata: [RepositoryMetadata!]!
  inProgressRunsByStep: [InProgressRunsByStep!]!
}

type RepositoryLocation {
  id: ID!
  name: String!
  isReloadSupported: Boolean!
  environmentPath: String
  repositories: [Repository!]!
  serverId: String
}

type Pipeline implements SolidContainer & IPipelineSnapshot {
  id: ID!
  name: String!
  description: String
  solids: [Solid!]!
  solidHandle(handleID: String!): SolidHandle
  solidHandles(parentHandleID: String): [SolidHandle!]!
  modes: [Mode!]!
  pipelineSnapshotId: String!
  dagsterTypes: [DagsterType!]!
  dagsterTypeOrError(dagsterTypeName: String!): DagsterTypeOrError!
  tags: [PipelineTag!]!
  runs(cursor: String, limit: Int): [Run!]!
  schedules: [Schedule!]!
  sensors: [Sensor!]!
  parentSnapshotId: String
  graphName: String!
  presets: [PipelinePreset!]!
  isJob: Boolean!
  isAssetJob: Boolean!
  repository: Repository!
  assetNodes(assetKeys: [AssetKeyInput!], loadMaterializations: Boolean = false): [AssetNode!]!
}

interface SolidContainer {
  id: ID!
  name: String!
  description: String
  solids: [Solid!]!
  solidHandle(handleID: String!): SolidHandle
  solidHandles(parentHandleID: String): [SolidHandle!]!
  modes: [Mode!]!
}

type Solid {
  name: String!
  definition: ISolidDefinition!
  inputs: [Input!]!
  outputs: [Output!]!
  isDynamicMapped: Boolean!
}

interface ISolidDefinition {
  name: String!
  description: String
  metadata: [MetadataItemDefinition!]!
  inputDefinitions: [InputDefinition!]!
  outputDefinitions: [OutputDefinition!]!
}

type MetadataItemDefinition {
  key: String!
  value: String!
}

type InputDefinition {
  solidDefinition: SolidDefinition!
  name: String!
  description: String
  type: DagsterType!
}

type SolidDefinition implements ISolidDefinition {
  name: String!
  description: String
  metadata: [MetadataItemDefinition!]!
  inputDefinitions: [InputDefinition!]!
  outputDefinitions: [OutputDefinition!]!
  configField: ConfigTypeField
  requiredResources: [ResourceRequirement!]!
}

type OutputDefinition {
  solidDefinition: SolidDefinition!
  name: String!
  description: String
  isDynamic: Boolean
  type: DagsterType!
}

interface DagsterType {
  key: String!
  name: String
  displayName: String!
  description: String
  isNullable: Boolean!
  isList: Boolean!
  isBuiltin: Boolean!
  isNothing: Boolean!
  inputSchemaType: ConfigType
  outputSchemaType: ConfigType
  innerTypes: [DagsterType!]!
}

interface ConfigType {
  key: String!
  description: String
  recursiveConfigTypes: [ConfigType!]!
  typeParamKeys: [String!]!
  isSelector: Boolean!
}

type ConfigTypeField {
  name: String!
  description: String
  configType: ConfigType!
  configTypeKey: String!
  isRequired: Boolean!
}

type ResourceRequirement {
  resourceKey: String!
}

type Input {
  solid: Solid!
  definition: InputDefinition!
  dependsOn: [Output!]!
  isDynamicCollect: Boolean!
}

type Output {
  solid: Solid!
  definition: OutputDefinition!
  dependedBy: [Input!]!
}

type SolidHandle {
  handleID: String!
  solid: Solid!
  parent: SolidHandle
  stepStats(limit: Int): SolidStepStatsOrError
}

union SolidStepStatsOrError = SolidStepStatsConnection | SolidStepStatusUnavailableError

type SolidStepStatsConnection {
  nodes: [RunStepStats!]!
}

type RunStepStats implements PipelineRunStepStats {
  runId: String!
  stepKey: String!
  status: StepEventStatus
  startTime: Float
  endTime: Float
  materializations: [Materialization!]!
  expectationResults: [ExpectationResult!]!
  attempts: [RunMarker!]!
  markers: [RunMarker!]!
}

interface PipelineRunStepStats {
  runId: String!
  stepKey: String!
  status: StepEventStatus
  startTime: Float
  endTime: Float
  materializations: [Materialization!]!
  expectationResults: [ExpectationResult!]!
}

enum StepEventStatus {
  SKIPPED
  SUCCESS
  FAILURE
  IN_PROGRESS
}

type Materialization implements DisplayableEvent {
  label: String!
  description: String
  metadataEntries: [EventMetadataEntry!]!
  assetKey: AssetKey
}

interface DisplayableEvent {
  label: String!
  description: String
  metadataEntries: [EventMetadataEntry!]!
}

interface EventMetadataEntry {
  label: String!
  description: String
}

type AssetKey {
  path: [String!]!
}

type ExpectationResult implements DisplayableEvent {
  label: String!
  description: String
  metadataEntries: [EventMetadataEntry!]!
  success: Boolean!
}

type RunMarker {
  startTime: Float
  endTime: Float
}

type SolidStepStatusUnavailableError implements Error {
  message: String!
}

interface Error {
  message: String!
}

type Mode {
  id: String!
  name: String!
  description: String
  resources: [Resource!]!
  loggers: [Logger!]!
}

type Resource {
  name: String!
  description: String
  configField: ConfigTypeField
}

type Logger {
  name: String!
  description: String
  configField: ConfigTypeField
}

interface IPipelineSnapshot {
  name: String!
  description: String
  pipelineSnapshotId: String!
  dagsterTypes: [DagsterType!]!
  dagsterTypeOrError(dagsterTypeName: String!): DagsterTypeOrError!
  solids: [Solid!]!
  modes: [Mode!]!
  solidHandles(parentHandleID: String): [SolidHandle!]!
  solidHandle(handleID: String!): SolidHandle
  tags: [PipelineTag!]!
  runs(cursor: String, limit: Int): [Run!]!
  schedules: [Schedule!]!
  sensors: [Sensor!]!
  parentSnapshotId: String
  graphName: String!
}

union DagsterTypeOrError = RegularDagsterType | PipelineNotFoundError | DagsterTypeNotFoundError | PythonError

type RegularDagsterType implements DagsterType {
  key: String!
  name: String
  displayName: String!
  description: String
  isNullable: Boolean!
  isList: Boolean!
  isBuiltin: Boolean!
  isNothing: Boolean!
  inputSchemaType: ConfigType
  outputSchemaType: ConfigType
  innerTypes: [DagsterType!]!
}

type PipelineNotFoundError implements Error {
  message: String!
  pipelineName: String!
  repositoryName: String!
  repositoryLocationName: String!
}

type DagsterTypeNotFoundError implements Error {
  message: String!
  dagsterTypeName: String!
}

type PythonError implements Error {
  message: String!
  className: String
  stack: [String!]!
  cause: PythonError
}

type PipelineTag {
  key: String!
  value: String!
}

type Run implements PipelineRun {
  id: ID!
  runId: String!
  pipelineSnapshotId: String
  repositoryOrigin: RepositoryOrigin
  status: RunStatus!
  pipeline: PipelineReference!
  pipelineName: String!
  jobName: String!
  solidSelection: [String!]
  stats: RunStatsSnapshotOrError!
  stepStats: [RunStepStats!]!
  computeLogs(stepKey: String!): ComputeLogs!
  executionPlan: ExecutionPlan
  stepKeysToExecute: [String!]
  runConfigYaml: String!
  runConfig: RunConfigData!
  mode: String!
  tags: [PipelineTag!]!
  rootRunId: String
  parentRunId: String
  canTerminate: Boolean!
  assets: [Asset!]!
  events(after: Cursor): [DagsterRunEvent!]!
  resolvedOpSelection: [String!]
}

interface PipelineRun {
  id: ID!
  runId: String!
  pipelineSnapshotId: String
  repositoryOrigin: RepositoryOrigin
  status: RunStatus!
  pipeline: PipelineReference!
  pipelineName: String!
  jobName: String!
  solidSelection: [String!]
  stats: RunStatsSnapshotOrError!
  stepStats: [RunStepStats!]!
  computeLogs(stepKey: String!): ComputeLogs!
  executionPlan: ExecutionPlan
  stepKeysToExecute: [String!]
  runConfigYaml: String!
  runConfig: RunConfigData!
  mode: String!
  tags: [PipelineTag!]!
  rootRunId: String
  parentRunId: String
  canTerminate: Boolean!
  assets: [Asset!]!
  events(after: Cursor): [DagsterRunEvent!]!
}

type RepositoryOrigin {
  id: String!
  repositoryLocationName: String!
  repositoryName: String!
  repositoryLocationMetadata: [RepositoryMetadata!]!
}

type RepositoryMetadata {
  key: String!
  value: String!
}

enum RunStatus {
  QUEUED
  NOT_STARTED
  MANAGED
  STARTING
  STARTED
  SUCCESS
  FAILURE
  CANCELING
  CANCELED
}

interface PipelineReference {
  name: String!
  solidSelection: [String!]
}

union RunStatsSnapshotOrError = RunStatsSnapshot | PythonError

type RunStatsSnapshot implements PipelineRunStatsSnapshot {
  id: String!
  runId: String!
  stepsSucceeded: Int!
  stepsFailed: Int!
  materializations: Int!
  expectations: Int!
  enqueuedTime: Float
  launchTime: Float
  startTime: Float
  endTime: Float
}

interface PipelineRunStatsSnapshot {
  id: String!
  runId: String!
  stepsSucceeded: Int!
  stepsFailed: Int!
  materializations: Int!
  expectations: Int!
  enqueuedTime: Float
  launchTime: Float
  startTime: Float
  endTime: Float
}

type ComputeLogs {
  runId: String!
  stepKey: String!
  stdout: ComputeLogFile
  stderr: ComputeLogFile
}

type ComputeLogFile {
  path: String!
  data: String
  cursor: Int!
  size: Int!
  downloadUrl: String
}

type ExecutionPlan {
  steps: [ExecutionStep!]!
  artifactsPersisted: Boolean!
}

type ExecutionStep {
  key: String!
  inputs: [ExecutionStepInput!]!
  outputs: [ExecutionStepOutput!]!
  solidHandleID: String!
  kind: StepKind!
  metadata: [MetadataItemDefinition!]!
}

type ExecutionStepInput {
  name: String!
  dependsOn: [ExecutionStep!]!
}

type ExecutionStepOutput {
  name: String!
}

enum StepKind {
  COMPUTE
  UNRESOLVED_MAPPED
  UNRESOLVED_COLLECT
}

scalar RunConfigData

type Asset {
  id: String!
  key: AssetKey!
  assetMaterializations(partitions: [String], beforeTimestampMillis: String, limit: Int): [AssetMaterialization!]!
  definition: AssetNode
}

type AssetMaterialization {
  materializationEvent: StepMaterializationEvent!
  runOrError: RunOrError!
  partition: String
}

type StepMaterializationEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  materialization: Materialization!
  stepStats: RunStepStats!
  assetLineage: [AssetLineageInfo!]!
}

interface MessageEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
}

enum LogLevel {
  CRITICAL
  ERROR
  INFO
  WARNING
  DEBUG
}

enum DagsterEventType {
  STEP_OUTPUT
  STEP_INPUT
  STEP_FAILURE
  STEP_START
  STEP_SUCCESS
  STEP_SKIPPED
  STEP_UP_FOR_RETRY
  STEP_RESTARTED
  ASSET_MATERIALIZATION
  STEP_EXPECTATION_RESULT
  RUN_ENQUEUED
  RUN_DEQUEUED
  RUN_STARTING
  RUN_START
  RUN_SUCCESS
  RUN_FAILURE
  RUN_CANCELING
  RUN_CANCELED
  PIPELINE_ENQUEUED
  PIPELINE_DEQUEUED
  PIPELINE_STARTING
  PIPELINE_START
  PIPELINE_SUCCESS
  PIPELINE_FAILURE
  PIPELINE_CANCELING
  PIPELINE_CANCELED
  OBJECT_STORE_OPERATION
  ASSET_STORE_OPERATION
  LOADED_INPUT
  HANDLED_OUTPUT
  ENGINE_EVENT
  HOOK_COMPLETED
  HOOK_ERRORED
  HOOK_SKIPPED
  ALERT_START
  ALERT_SUCCESS
  LOGS_CAPTURED
}

interface StepEvent {
  stepKey: String
  solidHandleID: String
}

type AssetLineageInfo {
  assetKey: AssetKey!
  partitions: [String!]!
}

union RunOrError = Run | RunNotFoundError | PythonError

type RunNotFoundError implements PipelineRunNotFoundError & Error {
  runId: String!
  message: String!
}

interface PipelineRunNotFoundError {
  runId: String!
  message: String!
}

type AssetNode {
  id: ID!
  assetKey: AssetKey!
  description: String
  opName: String
  jobs: [Pipeline!]!
  repository: Repository!
  dependencies: [AssetDependency!]!
  dependedBy: [AssetDependency!]!
  dependencyKeys: [AssetKey!]!
  dependedByKeys: [AssetKey!]!
  assetMaterializations(partitions: [String], beforeTimestampMillis: String, limit: Int): [AssetMaterialization!]!
  partitionKeys: [String!]!
  latestMaterializationByPartition(partitions: [String]): [AssetMaterialization]!
}

type AssetDependency {
  inputName: String!
  asset: AssetNode!
}

union DagsterRunEvent = ExecutionStepFailureEvent | ExecutionStepInputEvent | ExecutionStepOutputEvent | ExecutionStepSkippedEvent | ExecutionStepStartEvent | ExecutionStepSuccessEvent | ExecutionStepUpForRetryEvent | ExecutionStepRestartEvent | LogMessageEvent | RunFailureEvent | RunStartEvent | RunEnqueuedEvent | RunDequeuedEvent | RunStartingEvent | RunCancelingEvent | RunCanceledEvent | RunSuccessEvent | HandledOutputEvent | LoadedInputEvent | LogsCapturedEvent | ObjectStoreOperationEvent | StepExpectationResultEvent | StepMaterializationEvent | EngineEvent | HookCompletedEvent | HookSkippedEvent | HookErroredEvent | AlertStartEvent | AlertSuccessEvent

type ExecutionStepFailureEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  error: PythonError
  errorSource: ErrorSource
  failureMetadata: FailureMetadata
}

enum ErrorSource {
  FRAMEWORK_ERROR
  USER_CODE_ERROR
  UNEXPECTED_ERROR
  INTERRUPT
}

type FailureMetadata implements DisplayableEvent {
  label: String!
  description: String
  metadataEntries: [EventMetadataEntry!]!
}

type ExecutionStepInputEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  inputName: String!
  typeCheck: TypeCheck!
}

type TypeCheck implements DisplayableEvent {
  label: String!
  description: String
  metadataEntries: [EventMetadataEntry!]!
  success: Boolean!
}

type ExecutionStepOutputEvent implements MessageEvent & StepEvent & DisplayableEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  label: String!
  description: String
  metadataEntries: [EventMetadataEntry!]!
  outputName: String!
  typeCheck: TypeCheck!
}

type ExecutionStepSkippedEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
}

type ExecutionStepStartEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
}

type ExecutionStepSuccessEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
}

type ExecutionStepUpForRetryEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  error: PythonError
  secondsToWait: Int
}

type ExecutionStepRestartEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
}

type LogMessageEvent implements MessageEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
}

type RunFailureEvent implements MessageEvent & RunEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  pipelineName: String!
  error: PythonError
}

interface RunEvent {
  pipelineName: String!
}

type RunStartEvent implements MessageEvent & RunEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  pipelineName: String!
}

type RunEnqueuedEvent implements MessageEvent & RunEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  pipelineName: String!
}

type RunDequeuedEvent implements MessageEvent & RunEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  pipelineName: String!
}

type RunStartingEvent implements MessageEvent & RunEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  pipelineName: String!
}

type RunCancelingEvent implements MessageEvent & RunEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  pipelineName: String!
}

type RunCanceledEvent implements MessageEvent & RunEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  pipelineName: String!
}

type RunSuccessEvent implements MessageEvent & RunEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  pipelineName: String!
}

type HandledOutputEvent implements MessageEvent & StepEvent & DisplayableEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  label: String!
  description: String
  metadataEntries: [EventMetadataEntry!]!
  outputName: String!
  managerKey: String!
}

type LoadedInputEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  inputName: String!
  managerKey: String!
  upstreamOutputName: String
  upstreamStepKey: String
}

type LogsCapturedEvent implements MessageEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  logKey: String!
  stepKeys: [String!]
  pid: Int
}

type ObjectStoreOperationEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  operationResult: ObjectStoreOperationResult!
}

type ObjectStoreOperationResult implements DisplayableEvent {
  label: String!
  description: String
  metadataEntries: [EventMetadataEntry!]!
  op: ObjectStoreOperationType!
}

enum ObjectStoreOperationType {
  SET_OBJECT
  GET_OBJECT
  RM_OBJECT
  CP_OBJECT
}

type StepExpectationResultEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  expectationResult: ExpectationResult!
}

type EngineEvent implements MessageEvent & DisplayableEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  label: String!
  description: String
  metadataEntries: [EventMetadataEntry!]!
  error: PythonError
  markerStart: String
  markerEnd: String
}

type HookCompletedEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
}

type HookSkippedEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
}

type HookErroredEvent implements MessageEvent & StepEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  error: PythonError
}

type AlertStartEvent implements MessageEvent & RunEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  pipelineName: String!
}

type AlertSuccessEvent implements MessageEvent & RunEvent {
  runId: String!
  message: String!
  timestamp: String!
  level: LogLevel!
  stepKey: String
  solidHandleID: String
  eventType: DagsterEventType
  pipelineName: String!
}

scalar Cursor

type Schedule {
  id: ID!
  name: String!
  cronSchedule: String!
  pipelineName: String!
  solidSelection: [String]
  mode: String!
  executionTimezone: String
  description: String
  scheduleState: InstigationState!
  partitionSet: PartitionSet
  futureTicks(cursor: Float, limit: Int, until: Float): FutureInstigationTicks!
  futureTick(tickTimestamp: Int!): FutureInstigationTick!
}

type InstigationState {
  id: ID!
  name: String!
  instigationType: InstigationType!
  status: InstigationStatus!
  repositoryOrigin: RepositoryOrigin!
  typeSpecificData: InstigationTypeSpecificData
  runs(limit: Int): [Run!]!
  runsCount: Int!
  tick(timestamp: Float): InstigationTick
  ticks(dayRange: Int, dayOffset: Int, limit: Int): [InstigationTick!]!
  nextTick: FutureInstigationTick
  runningCount: Int!
}

enum InstigationType {
  SCHEDULE
  SENSOR
}

enum InstigationStatus {
  RUNNING
  STOPPED
}

union InstigationTypeSpecificData = SensorData | ScheduleData

type SensorData {
  lastTickTimestamp: Float
  lastRunKey: String
}

type ScheduleData {
  cronSchedule: String!
  startTimestamp: Float
}

type InstigationTick {
  id: ID!
  status: InstigationTickStatus!
  timestamp: Float!
  runIds: [String!]!
  error: PythonError
  skipReason: String
  runs: [Run!]!
  originRunIds: [String!]!
}

enum InstigationTickStatus {
  STARTED
  SKIPPED
  SUCCESS
  FAILURE
}

type FutureInstigationTick {
  timestamp: Float!
  evaluationResult: TickEvaluation
}

type TickEvaluation {
  runRequests: [RunRequest]
  skipReason: String
  error: PythonError
}

type RunRequest {
  runKey: String
  tags: [PipelineTag!]!
  runConfigYaml: String!
}

type PartitionSet {
  id: ID!
  name: String!
  pipelineName: String!
  solidSelection: [String!]
  mode: String!
  partitionsOrError(cursor: String, limit: Int, reverse: Boolean): PartitionsOrError!
  partition(partitionName: String!): Partition
  partitionStatusesOrError: PartitionStatusesOrError!
  repositoryOrigin: RepositoryOrigin!
}

union PartitionsOrError = Partitions | PythonError

type Partitions {
  results: [Partition!]!
}

type Partition {
  name: String!
  partitionSetName: String!
  solidSelection: [String!]
  mode: String!
  runConfigOrError: PartitionRunConfigOrError!
  tagsOrError: PartitionTagsOrError!
  runs(filter: RunsFilter, cursor: String, limit: Int): [Run!]!
  status: RunStatus
}

union PartitionRunConfigOrError = PartitionRunConfig | PythonError

type PartitionRunConfig {
  yaml: String!
}

union PartitionTagsOrError = PartitionTags | PythonError

type PartitionTags {
  results: [PipelineTag!]!
}

input RunsFilter {
  runIds: [String]
  pipelineName: String
  tags: [ExecutionTag!]
  statuses: [RunStatus!]
  snapshotId: String
  updatedAfter: String
  mode: String
}

input ExecutionTag {
  key: String!
  value: String!
}

union PartitionStatusesOrError = PartitionStatuses | PythonError

type PartitionStatuses {
  results: [PartitionStatus!]!
}

type PartitionStatus {
  id: String!
  partitionName: String!
  runStatus: RunStatus
}

type FutureInstigationTicks {
  results: [FutureInstigationTick!]!
  cursor: Float!
}

type Sensor {
  id: ID!
  jobOriginId: String!
  name: String!
  targets: [Target!]
  sensorState: InstigationState!
  minIntervalSeconds: Int!
  description: String
  nextTick: FutureInstigationTick
  metadata: SensorMetadata!
}

type Target {
  pipelineName: String!
  mode: String!
  solidSelection: [String!]
}

type SensorMetadata {
  assetKeys: [AssetKey!]
}

type PipelinePreset {
  name: String!
  solidSelection: [String!]
  runConfigYaml: String!
  mode: String!
  tags: [PipelineTag!]!
}

input AssetKeyInput {
  path: [String!]!
}

type Job implements SolidContainer & IPipelineSnapshot {
  id: ID!
  name: String!
  description: String
  solids: [Solid!]!
  solidHandle(handleID: String!): SolidHandle
  solidHandles(parentHandleID: String): [SolidHandle!]!
  modes: [Mode!]!
  pipelineSnapshotId: String!
  dagsterTypes: [DagsterType!]!
  dagsterTypeOrError(dagsterTypeName: String!): DagsterTypeOrError!
  tags: [PipelineTag!]!
  runs(cursor: String, limit: Int): [Run!]!
  schedules: [Schedule!]!
  sensors: [Sensor!]!
  parentSnapshotId: String
  graphName: String!
  presets: [PipelinePreset!]!
  isJob: Boolean!
  isAssetJob: Boolean!
  repository: Repository!
  assetNodes(assetKeys: [AssetKeyInput!], loadMaterializations: Boolean = false): [AssetNode!]!
}

type UsedSolid {
  definition: ISolidDefinition!
  invocations: [NodeInvocationSite!]!
}

type NodeInvocationSite {
  pipeline: Pipeline!
  solidHandle: SolidHandle!
}

type InProgressRunsByStep {
  stepKey: String!
  unstartedRuns: [Run!]!
  inProgressRuns: [Run!]!
}

union RepositoryOrError = PythonError | Repository | RepositoryNotFoundError

type RepositoryNotFoundError implements Error {
  message: String!
  repositoryName: String!
  repositoryLocationName: String!
}

input RepositorySelector {
  repositoryName: String!
  repositoryLocationName: String!
}

union WorkspaceOrError = Workspace | PythonError

type Workspace {
  locationEntries: [WorkspaceLocationEntry!]!
}

type WorkspaceLocationEntry {
  id: ID!
  name: String!
  locationOrLoadError: RepositoryLocationOrLoadError
  loadStatus: RepositoryLocationLoadStatus!
  displayMetadata: [RepositoryMetadata!]!
  updatedTimestamp: Float!
}

union RepositoryLocationOrLoadError = RepositoryLocation | PythonError

enum RepositoryLocationLoadStatus {
  LOADING
  LOADED
}

union PipelineOrError = Pipeline | PipelineNotFoundError | InvalidSubsetError | PythonError

type InvalidSubsetError implements Error {
  message: String!
  pipeline: Pipeline!
}

input PipelineSelector {
  pipelineName: String!
  repositoryName: String!
  repositoryLocationName: String!
  solidSelection: [String!]
}

union PipelineSnapshotOrError = PipelineNotFoundError | PipelineSnapshot | PipelineSnapshotNotFoundError | PythonError

type PipelineSnapshot implements SolidContainer & IPipelineSnapshot & PipelineReference {
  id: ID!
  name: String!
  description: String
  solids: [Solid!]!
  solidHandle(handleID: String!): SolidHandle
  solidHandles(parentHandleID: String): [SolidHandle!]!
  modes: [Mode!]!
  pipelineSnapshotId: String!
  dagsterTypes: [DagsterType!]!
  dagsterTypeOrError(dagsterTypeName: String!): DagsterTypeOrError!
  tags: [PipelineTag!]!
  runs(cursor: String, limit: Int): [Run!]!
  schedules: [Schedule!]!
  sensors: [Sensor!]!
  parentSnapshotId: String
  graphName: String!
  solidSelection: [String!]
}

type PipelineSnapshotNotFoundError implements Error {
  message: String!
  snapshotId: String!
}

union GraphOrError = Graph | GraphNotFoundError | PythonError

type Graph implements SolidContainer {
  id: ID!
  name: String!
  description: String
  solids: [Solid!]!
  solidHandle(handleID: String!): SolidHandle
  solidHandles(parentHandleID: String): [SolidHandle!]!
  modes: [Mode!]!
}

type GraphNotFoundError implements Error {
  message: String!
  graphName: String!
  repositoryName: String!
  repositoryLocationName: String!
}

input GraphSelector {
  graphName: String!
  repositoryName: String!
  repositoryLocationName: String!
}

union SchedulerOrError = Scheduler | SchedulerNotDefinedError | PythonError

type Scheduler {
  schedulerClass: String
}

type SchedulerNotDefinedError implements Error {
  message: String!
}

union ScheduleOrError = Schedule | ScheduleNotFoundError | PythonError

type ScheduleNotFoundError implements Error {
  message: String!
  scheduleName: String!
}

input ScheduleSelector {
  repositoryName: String!
  repositoryLocationName: String!
  scheduleName: String!
}

union SchedulesOrError = Schedules | RepositoryNotFoundError | PythonError

type Schedules {
  results: [Schedule!]!
}

union SensorOrError = Sensor | SensorNotFoundError | UnauthorizedError | PythonError

type SensorNotFoundError implements Error {
  message: String!
  sensorName: String!
}

type UnauthorizedError implements Error {
  message: String!
}

input SensorSelector {
  repositoryName: String!
  repositoryLocationName: String!
  sensorName: String!
}

union SensorsOrError = Sensors | RepositoryNotFoundError | PythonError

type Sensors {
  results: [Sensor!]!
}

union InstigationStateOrError = InstigationState | PythonError

input InstigationSelector {
  repositoryName: String!
  repositoryLocationName: String!
  name: String!
}

union InstigationStatesOrError = InstigationStates | PythonError

type InstigationStates {
  results: [InstigationState!]!
}

union PartitionSetsOrError = PartitionSets | PipelineNotFoundError | PythonError

type PartitionSets {
  results: [PartitionSet!]!
}

union PartitionSetOrError = PartitionSet | PartitionSetNotFoundError | PythonError

type PartitionSetNotFoundError implements Error {
  message: String!
  partitionSetName: String!
}

union RunsOrError = Runs | InvalidPipelineRunsFilterError | PythonError

type Runs implements PipelineRuns {
  results: [Run!]!
  count: Int
}

interface PipelineRuns {
  results: [Run!]!
  count: Int
}

type InvalidPipelineRunsFilterError implements Error {
  message: String!
}

type PipelineTagAndValues {
  key: String!
  values: [String!]!
}

union RunGroupOrError = RunGroup | RunGroupNotFoundError | PythonError

type RunGroup {
  rootRunId: String!
  runs: [Run]
}

type RunGroupNotFoundError implements Error {
  message: String!
  runId: String!
}

type RunGroupsOrError {
  results: [RunGroup!]!
}

union PipelineConfigValidationResult = InvalidSubsetError | PipelineConfigValidationValid | RunConfigValidationInvalid | PipelineNotFoundError | PythonError

type PipelineConfigValidationValid {
  pipelineName: String!
}

type RunConfigValidationInvalid implements PipelineConfigValidationInvalid {
  pipelineName: String!
  errors: [PipelineConfigValidationError!]!
}

interface PipelineConfigValidationInvalid {
  pipelineName: String!
  errors: [PipelineConfigValidationError!]!
}

interface PipelineConfigValidationError {
  message: String!
  path: [String!]!
  stack: EvaluationStack!
  reason: EvaluationErrorReason!
}

type EvaluationStack {
  entries: [EvaluationStackEntry!]!
}

union EvaluationStackEntry = EvaluationStackListItemEntry | EvaluationStackPathEntry

type EvaluationStackListItemEntry {
  listIndex: Int!
}

type EvaluationStackPathEntry {
  fieldName: String!
}

enum EvaluationErrorReason {
  RUNTIME_TYPE_MISMATCH
  MISSING_REQUIRED_FIELD
  MISSING_REQUIRED_FIELDS
  FIELD_NOT_DEFINED
  FIELDS_NOT_DEFINED
  SELECTOR_FIELD_ERROR
}

union ExecutionPlanOrError = ExecutionPlan | RunConfigValidationInvalid | PipelineNotFoundError | InvalidSubsetError | PythonError

union RunConfigSchemaOrError = RunConfigSchema | PipelineNotFoundError | InvalidSubsetError | ModeNotFoundError | PythonError

type RunConfigSchema {
  rootConfigType: ConfigType!
  allConfigTypes: [ConfigType!]!
  isRunConfigValid(runConfigData: RunConfigData): PipelineConfigValidationResult!
}

type ModeNotFoundError implements Error {
  message: String!
  mode: String!
}

type Instance {
  info: String
  runLauncher: RunLauncher
  runQueuingSupported: Boolean!
  executablePath: String!
  daemonHealth: DaemonHealth!
  hasInfo: Boolean!
  dagitTelemetryEnabled: Boolean!
}

type RunLauncher {
  name: String!
}

type DaemonHealth {
  id: String!
  daemonStatus(daemonType: String): DaemonStatus!
  allDaemonStatuses: [DaemonStatus!]!
}

type DaemonStatus {
  daemonType: String!
  id: ID!
  required: Boolean!
  healthy: Boolean
  lastHeartbeatTime: Float
  lastHeartbeatErrors: [PythonError!]!
}

union AssetsOrError = AssetConnection | PythonError

type AssetConnection {
  nodes: [Asset!]!
}

union AssetOrError = Asset | AssetNotFoundError

type AssetNotFoundError implements Error {
  message: String!
}

union AssetNodeOrError = AssetNode | AssetNotFoundError

union PartitionBackfillOrError = PartitionBackfill | PythonError

type PartitionBackfill {
  backfillId: String!
  status: BulkActionStatus!
  numRequested: Int!
  numTotal: Int!
  fromFailure: Boolean!
  reexecutionSteps: [String!]!
  partitionSetName: String!
  timestamp: Float!
  partitionSet: PartitionSet
  runs(limit: Int): [Run!]!
  error: PythonError
}

enum BulkActionStatus {
  REQUESTED
  COMPLETED
  FAILED
  CANCELED
}

union PartitionBackfillsOrError = PartitionBackfills | PythonError

type PartitionBackfills {
  results: [PartitionBackfill!]!
}

type GraphenePermission {
  permission: String!
  value: Boolean!
}

type DagitMutation {
  launchPipelineExecution(executionParams: ExecutionParams!): LaunchRunResult!
  launchRun(executionParams: ExecutionParams!): LaunchRunResult!
  launchPipelineReexecution(executionParams: ExecutionParams!): LaunchRunReexecutionResult!
  launchRunReexecution(executionParams: ExecutionParams!): LaunchRunReexecutionResult!
  startSchedule(scheduleSelector: ScheduleSelector!): ScheduleMutationResult!
  stopRunningSchedule(scheduleOriginId: String!): ScheduleMutationResult!
  startSensor(sensorSelector: SensorSelector!): SensorOrError!
  stopSensor(jobOriginId: String!): StopSensorMutationResultOrError!
  terminatePipelineExecution(runId: String!, terminatePolicy: TerminateRunPolicy): TerminateRunResult!
  terminateRun(runId: String!, terminatePolicy: TerminateRunPolicy): TerminateRunResult!
  deletePipelineRun(runId: String!): DeletePipelineRunResult!
  deleteRun(runId: String!): DeletePipelineRunResult!
  reloadRepositoryLocation(repositoryLocationName: String!): ReloadRepositoryLocationMutationResult!
  reloadWorkspace: ReloadWorkspaceMutationResult!
  shutdownRepositoryLocation(repositoryLocationName: String!): ShutdownRepositoryLocationMutationResult!
  wipeAssets(assetKeys: [AssetKeyInput!]!): AssetWipeMutationResult!
  launchPartitionBackfill(backfillParams: LaunchBackfillParams!): LaunchBackfillResult!
  resumePartitionBackfill(backfillId: String!): ResumeBackfillResult!
  cancelPartitionBackfill(backfillId: String!): CancelBackfillResult!
  logTelemetry(action: String!, clientTime: String!, metadata: String!): LogTelemetryMutationResult!
}

union LaunchRunResult = LaunchRunSuccess | InvalidStepError | InvalidOutputError | RunConfigValidationInvalid | PipelineNotFoundError | RunConflict | UnauthorizedError | PythonError | PresetNotFoundError | ConflictingExecutionParamsError | NoModeProvidedError

type LaunchRunSuccess implements LaunchPipelineRunSuccess {
  run: Run!
}

interface LaunchPipelineRunSuccess {
  run: Run!
}

type InvalidStepError {
  invalidStepKey: String!
}

type InvalidOutputError {
  stepKey: String!
  invalidOutputName: String!
}

type RunConflict implements Error & PipelineRunConflict {
  message: String!
}

interface PipelineRunConflict {
  message: String!
}

type PresetNotFoundError implements Error {
  message: String!
  preset: String!
}

type ConflictingExecutionParamsError implements Error {
  message: String!
}

type NoModeProvidedError implements Error {
  message: String!
  pipelineName: String!
}

input ExecutionParams {
  selector: JobOrPipelineSelector!
  runConfigData: RunConfigData
  mode: String
  executionMetadata: ExecutionMetadata
  stepKeys: [String!]
  preset: String
}

input JobOrPipelineSelector {
  pipelineName: String
  jobName: String
  repositoryName: String!
  repositoryLocationName: String!
  solidSelection: [String!]
}

input ExecutionMetadata {
  runId: String
  tags: [ExecutionTag!]
  rootRunId: String
  parentRunId: String
}

union LaunchRunReexecutionResult = LaunchRunSuccess | InvalidStepError | InvalidOutputError | RunConfigValidationInvalid | PipelineNotFoundError | RunConflict | UnauthorizedError | PythonError | PresetNotFoundError | ConflictingExecutionParamsError | NoModeProvidedError

union ScheduleMutationResult = PythonError | ScheduleStateResult

type ScheduleStateResult {
  scheduleState: InstigationState!
}

union StopSensorMutationResultOrError = StopSensorMutationResult | UnauthorizedError | PythonError

type StopSensorMutationResult {
  instigationState: InstigationState
}

union TerminateRunResult = TerminateRunSuccess | TerminateRunFailure | RunNotFoundError | UnauthorizedError | PythonError

type TerminateRunSuccess implements TerminatePipelineExecutionSuccess {
  run: Run!
}

interface TerminatePipelineExecutionSuccess {
  run: Run!
}

type TerminateRunFailure implements TerminatePipelineExecutionFailure {
  run: Run!
  message: String!
}

interface TerminatePipelineExecutionFailure {
  run: Run!
  message: String!
}

enum TerminateRunPolicy {
  SAFE_TERMINATE
  MARK_AS_CANCELED_IMMEDIATELY
}

union DeletePipelineRunResult = DeletePipelineRunSuccess | UnauthorizedError | PythonError | RunNotFoundError

type DeletePipelineRunSuccess {
  runId: String!
}

union ReloadRepositoryLocationMutationResult = WorkspaceLocationEntry | ReloadNotSupported | RepositoryLocationNotFound | UnauthorizedError | PythonError

type ReloadNotSupported implements Error {
  message: String!
}

type RepositoryLocationNotFound implements Error {
  message: String!
}

union ReloadWorkspaceMutationResult = Workspace | UnauthorizedError | PythonError

union ShutdownRepositoryLocationMutationResult = ShutdownRepositoryLocationSuccess | RepositoryLocationNotFound | UnauthorizedError | PythonError

type ShutdownRepositoryLocationSuccess {
  repositoryLocationName: String!
}

union AssetWipeMutationResult = AssetNotFoundError | UnauthorizedError | PythonError | AssetWipeSuccess

type AssetWipeSuccess {
  assetKeys: [AssetKey!]!
}

union LaunchBackfillResult = LaunchBackfillSuccess | PartitionSetNotFoundError | InvalidStepError | InvalidOutputError | RunConfigValidationInvalid | PipelineNotFoundError | RunConflict | UnauthorizedError | PythonError | PresetNotFoundError | ConflictingExecutionParamsError | NoModeProvidedError

type LaunchBackfillSuccess {
  backfillId: String!
  launchedRunIds: [String]
}

input LaunchBackfillParams {
  selector: PartitionSetSelector!
  partitionNames: [String!]!
  reexecutionSteps: [String!]
  fromFailure: Boolean
  tags: [ExecutionTag!]
  forceSynchronousSubmission: Boolean
}

input PartitionSetSelector {
  partitionSetName: String!
  repositorySelector: RepositorySelector!
}

union ResumeBackfillResult = ResumeBackfillSuccess | UnauthorizedError | PythonError

type ResumeBackfillSuccess {
  backfillId: String!
}

union CancelBackfillResult = CancelBackfillSuccess | UnauthorizedError | PythonError

type CancelBackfillSuccess {
  backfillId: String!
}

union LogTelemetryMutationResult = LogTelemetrySuccess | PythonError

type LogTelemetrySuccess {
  action: String!
}

type DagitSubscription {
  pipelineRunLogs(runId: ID!, after: Cursor): PipelineRunLogsSubscriptionPayload!
  computeLogs(runId: ID!, stepKey: String!, ioType: ComputeIOType!, cursor: String): ComputeLogFile!
  locationStateChangeEvents: LocationStateChangeSubscription!
}

union PipelineRunLogsSubscriptionPayload = PipelineRunLogsSubscriptionSuccess | PipelineRunLogsSubscriptionFailure

type PipelineRunLogsSubscriptionSuccess {
  run: Run!
  messages: [DagsterRunEvent!]!
  hasMorePastEvents: Boolean!
}

type PipelineRunLogsSubscriptionFailure {
  message: String!
  missingRunId: String
}

enum ComputeIOType {
  STDOUT
  STDERR
}

type LocationStateChangeSubscription {
  event: LocationStateChangeEvent!
}

type LocationStateChangeEvent {
  eventType: LocationStateChangeEventType!
  message: String!
  locationName: String!
  serverId: String
}

enum LocationStateChangeEventType {
  LOCATION_UPDATED
  LOCATION_DISCONNECTED
  LOCATION_RECONNECTED
  LOCATION_ERROR
}

type EventPipelineRunMetadataEntry implements EventMetadataEntry {
  label: String!
  description: String
  runId: String!
}

type EventAssetMetadataEntry implements EventMetadataEntry {
  label: String!
  description: String
  assetKey: AssetKey!
}

type EventFloatMetadataEntry implements EventMetadataEntry {
  label: String!
  description: String
  floatValue: Float
}

type EventIntMetadataEntry implements EventMetadataEntry {
  label: String!
  description: String
  intValue: Int
  intRepr: String!
}

type EventJsonMetadataEntry implements EventMetadataEntry {
  label: String!
  description: String
  jsonString: String!
}

type EventMarkdownMetadataEntry implements EventMetadataEntry {
  label: String!
  description: String
  mdStr: String!
}

type EventPathMetadataEntry implements EventMetadataEntry {
  label: String!
  description: String
  path: String!
}

type EventPythonArtifactMetadataEntry implements EventMetadataEntry {
  label: String!
  description: String
  module: String!
  name: String!
}

type EventTextMetadataEntry implements EventMetadataEntry {
  label: String!
  description: String
  text: String!
}

type EventUrlMetadataEntry implements EventMetadataEntry {
  label: String!
  description: String
  url: String!
}

type MissingRunIdErrorEvent {
  invalidRunId: String!
}

type ConfigTypeNotFoundError implements Error {
  message: String!
  pipeline: Pipeline!
  configTypeName: String!
}

type FieldNotDefinedConfigError implements PipelineConfigValidationError {
  message: String!
  path: [String!]!
  stack: EvaluationStack!
  reason: EvaluationErrorReason!
  fieldName: String!
}

type FieldsNotDefinedConfigError implements PipelineConfigValidationError {
  message: String!
  path: [String!]!
  stack: EvaluationStack!
  reason: EvaluationErrorReason!
  fieldNames: [String!]!
}

type MissingFieldConfigError implements PipelineConfigValidationError {
  message: String!
  path: [String!]!
  stack: EvaluationStack!
  reason: EvaluationErrorReason!
  field: ConfigTypeField!
}

type MissingFieldsConfigError implements PipelineConfigValidationError {
  message: String!
  path: [String!]!
  stack: EvaluationStack!
  reason: EvaluationErrorReason!
  fields: [ConfigTypeField!]!
}

type RuntimeMismatchConfigError implements PipelineConfigValidationError {
  message: String!
  path: [String!]!
  stack: EvaluationStack!
  reason: EvaluationErrorReason!
  valueRep: String
}

type SelectorTypeConfigError implements PipelineConfigValidationError {
  message: String!
  path: [String!]!
  stack: EvaluationStack!
  reason: EvaluationErrorReason!
  incomingFields: [String!]!
}

type UnknownPipeline implements PipelineReference {
  name: String!
  solidSelection: [String!]
}

type DeleteRunMutation {
  Output: DeletePipelineRunResult!
}

type LaunchBackfillMutation {
  Output: LaunchBackfillResult!
}

type LaunchRunMutation {
  Output: LaunchRunResult!
}

type LaunchRunReexecutionMutation {
  Output: LaunchRunReexecutionResult!
}

type ReloadRepositoryLocationMutation {
  Output: ReloadRepositoryLocationMutationResult!
}

type ReloadWorkspaceMutation {
  Output: ReloadWorkspaceMutationResult!
}

type ShutdownRepositoryLocationMutation {
  Output: ShutdownRepositoryLocationMutationResult!
}

type TerminateRunMutation {
  Output: TerminateRunResult!
}

enum ScheduleStatus {
  RUNNING
  STOPPED
  ENDED
}

type ScheduleTick {
  tickId: String!
  status: InstigationTickStatus!
  timestamp: Float!
  tickSpecificData: ScheduleTickSpecificData
}

union ScheduleTickSpecificData = ScheduleTickSuccessData | ScheduleTickFailureData

type ScheduleTickSuccessData {
  run: Run
}

type ScheduleTickFailureData {
  error: PythonError!
}

type ScheduleTickStatsSnapshot {
  ticksStarted: Int!
  ticksSucceeded: Int!
  ticksSkipped: Int!
  ticksFailed: Int!
}

type StartScheduleMutation {
  Output: ScheduleMutationResult!
}

type StopRunningScheduleMutation {
  Output: ScheduleMutationResult!
}

union ConfigTypeOrError = EnumConfigType | CompositeConfigType | RegularConfigType | PipelineNotFoundError | ConfigTypeNotFoundError | PythonError

type EnumConfigType implements ConfigType {
  key: String!
  description: String
  recursiveConfigTypes: [ConfigType!]!
  typeParamKeys: [String!]!
  isSelector: Boolean!
  values: [EnumConfigValue!]!
  givenName: String!
}

type EnumConfigValue {
  value: String!
  description: String
}

type CompositeConfigType implements ConfigType {
  key: String!
  description: String
  recursiveConfigTypes: [ConfigType!]!
  typeParamKeys: [String!]!
  isSelector: Boolean!
  fields: [ConfigTypeField!]!
}

type RegularConfigType implements ConfigType {
  key: String!
  description: String
  recursiveConfigTypes: [ConfigType!]!
  typeParamKeys: [String!]!
  isSelector: Boolean!
  givenName: String!
}

type ArrayConfigType implements ConfigType & WrappingConfigType {
  key: String!
  description: String
  recursiveConfigTypes: [ConfigType!]!
  typeParamKeys: [String!]!
  isSelector: Boolean!
  ofType: ConfigType!
}

interface WrappingConfigType {
  ofType: ConfigType!
}

type NullableConfigType implements ConfigType & WrappingConfigType {
  key: String!
  description: String
  recursiveConfigTypes: [ConfigType!]!
  typeParamKeys: [String!]!
  isSelector: Boolean!
  ofType: ConfigType!
}

type ScalarUnionConfigType implements ConfigType {
  key: String!
  description: String
  recursiveConfigTypes: [ConfigType!]!
  typeParamKeys: [String!]!
  isSelector: Boolean!
  scalarType: ConfigType!
  nonScalarType: ConfigType!
  scalarTypeKey: String!
  nonScalarTypeKey: String!
}

type ListDagsterType implements DagsterType & WrappingDagsterType {
  key: String!
  name: String
  displayName: String!
  description: String
  isNullable: Boolean!
  isList: Boolean!
  isBuiltin: Boolean!
  isNothing: Boolean!
  inputSchemaType: ConfigType
  outputSchemaType: ConfigType
  innerTypes: [DagsterType!]!
  ofType: DagsterType!
}

interface WrappingDagsterType {
  ofType: DagsterType!
}

type NullableDagsterType implements DagsterType & WrappingDagsterType {
  key: String!
  name: String
  displayName: String!
  description: String
  isNullable: Boolean!
  isList: Boolean!
  isBuiltin: Boolean!
  isNothing: Boolean!
  inputSchemaType: ConfigType
  outputSchemaType: ConfigType
  innerTypes: [DagsterType!]!
  ofType: DagsterType!
}

input MarshalledInput {
  inputName: String!
  key: String!
}

input MarshalledOutput {
  outputName: String!
  key: String!
}

input StepExecution {
  stepKey: String!
  marshalledInputs: [MarshalledInput!]
  marshalledOutputs: [MarshalledOutput!]
}

input StepOutputHandle {
  stepKey: String!
  outputName: String!
}

type RunGroups {
  results: [RunGroup!]!
}

type StopSensorMutation {
  Output: StopSensorMutationResultOrError!
}

type CompositeSolidDefinition implements ISolidDefinition & SolidContainer {
  name: String!
  description: String
  metadata: [MetadataItemDefinition!]!
  inputDefinitions: [InputDefinition!]!
  outputDefinitions: [OutputDefinition!]!
  id: ID!
  solids: [Solid!]!
  solidHandle(handleID: String!): SolidHandle
  solidHandles(parentHandleID: String): [SolidHandle!]!
  modes: [Mode!]!
  inputMappings: [InputMapping!]!
  outputMappings: [OutputMapping!]!
}

type InputMapping {
  mappedInput: Input!
  definition: InputDefinition!
}

type OutputMapping {
  mappedOutput: Output!
  definition: OutputDefinition!
}
